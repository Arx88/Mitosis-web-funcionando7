"""
CORRECCI√ìN CR√çTICA: Generador de Keywords Inteligente
Reemplazo completo para las funciones problem√°ticas de generaci√≥n de t√©rminos de b√∫squeda

PROBLEMA IDENTIFICADO:
- unified_web_search_tool.py l√≠neas 1080, 204-205 generan keywords sin sentido
- Regex destructivos que eliminan contexto esencial 
- T√©rminos como "REALIZA INFORME" que no devuelven resultados √∫tiles

SOLUCI√ìN IMPLEMENTADA:
- Extracci√≥n inteligente de entidades y conceptos principales
- Preservaci√≥n del contexto y tema central
- M√∫ltiples estrategias de fallback inteligentes
"""

import re
import logging
from typing import List, Tuple, Optional
from datetime import datetime

logger = logging.getLogger(__name__)

class IntelligentKeywordGenerator:
    """
    üß† GENERADOR INTELIGENTE DE KEYWORDS PARA B√öSQUEDAS WEB
    
    Reemplaza las funciones problem√°ticas con l√≥gica avanzada que:
    1. Preserva el contexto esencial de la consulta
    2. Extrae entidades principales (personas, lugares, conceptos)
    3. Genera m√∫ltiples variantes de b√∫squeda espec√≠ficas
    4. Evita t√©rminos meta que no producen resultados √∫tiles
    """
    
    def __init__(self):
        # Palabras que deben ser preservadas siempre (entidades pol√≠ticas, econ√≥micas, etc)
        self.preserve_words = {
            'milei', 'argentina', 'javier', 'presidente', 'pol√≠tico', 'econom√≠a', 'inflaci√≥n',
            'ideolog√≠a', 'declaraciones', 'biograf√≠a', 'trayectoria', 'libertario',
            'arctic', 'monkeys', 'banda', 'm√∫sica', 'rock', 'discograf√≠a',
            'inteligencia', 'artificial', 'ai', 'tecnolog√≠a', 'datos', 'machine', 'learning'
        }
        
        # Palabras meta que deben ser eliminadas completamente
        self.meta_words = {
            'buscar', 'informaci√≥n', 'sobre', 'utilizar', 'herramienta', 'web_search',
            'realizar', 'an√°lisis', 'genera', 'informe', 'espec√≠fica', 'actualizada',
            'relacionadas', 'noticias', 'datos', 'para', 'con', 'una', 'del', 'las', 'los',
            'que', 'esta', 'este', 'a√±o', 'search', 'estado', 'completa', 'general'
        }
    
    def generate_smart_keywords(self, original_query: str, max_keywords: int = 4) -> str:
        """
        üéØ GENERAR KEYWORDS INTELIGENTES DESDE QUERY ORIGINAL
        
        Args:
            original_query: Query original del usuario
            max_keywords: M√°ximo n√∫mero de keywords a generar
            
        Returns:
            str: Keywords optimizados para b√∫squeda web efectiva
        """
        try:
            # Log de debugging para verificar entrada
            logger.info(f"üîç KEYWORD GENERATION: Input '{original_query}'")
            print(f"üîç KEYWORDS DEBUG: Generating from '{original_query}'")
            
            # ESTRATEGIA 1: Detectar y preservar nombres propios/entidades
            proper_nouns = self._extract_proper_nouns(original_query)
            if proper_nouns:
                result = self._build_query_with_entities(proper_nouns, original_query)
                print(f"‚úÖ STRATEGY 1 - Proper nouns: '{result}'")
                if self._validate_keyword_quality(result):
                    return result
            
            # ESTRATEGIA 2: Identificar tema central y conceptos relacionados
            central_theme = self._identify_central_theme(original_query)
            if central_theme:
                result = self._build_themed_query(central_theme, original_query)
                print(f"‚úÖ STRATEGY 2 - Central theme: '{result}'")
                if self._validate_keyword_quality(result):
                    return result
            
            # ESTRATEGIA 3: Extracci√≥n inteligente de keywords significativos
            significant_words = self._extract_significant_words(original_query)
            if len(significant_words) >= 2:
                result = ' '.join(significant_words[:max_keywords])
                print(f"‚úÖ STRATEGY 3 - Significant words: '{result}'")
                if self._validate_keyword_quality(result):
                    return result
            
            # ESTRATEGIA 4: Fallback inteligente basado en categor√≠as
            category_based = self._generate_category_based_keywords(original_query)
            if category_based:
                print(f"‚úÖ STRATEGY 4 - Category based: '{category_based}'")
                return category_based
            
            # √öLTIMO RECURSO: Preservar cualquier palabra importante encontrada
            last_resort = self._extract_any_useful_words(original_query)
            print(f"‚ö†Ô∏è LAST RESORT - Any useful: '{last_resort}'")
            return last_resort
            
        except Exception as e:
            logger.error(f"‚ùå Error generating keywords: {str(e)}")
            return "b√∫squeda informaci√≥n actual"
    
    def _extract_proper_nouns(self, text: str) -> List[str]:
        """Extraer nombres propios/entidades con precisi√≥n"""
        # Detectar nombres propios (palabras que empiezan con may√∫scula)
        proper_nouns = re.findall(r'\b[A-Z√Å√â√ç√ì√ö√ë][a-z√°√©√≠√≥√∫√±]{2,}(?:\s+[A-Z√Å√â√ç√ì√ö√ë][a-z√°√©√≠√≥√∫√±]+)*\b', text)
        
        # Filtrar nombres v√°lidos (no palabras al inicio de oraci√≥n)
        valid_nouns = []
        for noun in proper_nouns:
            # Verificar que no sea solo una palabra com√∫n capitalizada al inicio
            if any(preserve_word in noun.lower() for preserve_word in self.preserve_words):
                valid_nouns.append(noun)
        
        return valid_nouns
    
    def _build_query_with_entities(self, entities: List[str], original_query: str) -> str:
        """Construir query preservando entidades principales"""
        # Combinar entidades principales
        entity_query = ' '.join(entities).lower()
        
        # Detectar tipo de consulta y agregar contexto apropiado
        query_lower = original_query.lower()
        
        if any(word in query_lower for word in ['biograf√≠a', 'trayectoria', 'ideolog√≠a', 'pol√≠tico']):
            return f"{entity_query} biograf√≠a pol√≠tica ideolog√≠a"
        elif any(word in query_lower for word in ['econ√≥mico', 'econom√≠a', 'inflaci√≥n', 'argentina']):
            return f"{entity_query} econom√≠a argentina datos"
        elif any(word in query_lower for word in ['banda', 'm√∫sica', 'rock', 'discograf√≠a']):
            return f"{entity_query} m√∫sica discograf√≠a informaci√≥n"
        elif any(word in query_lower for word in ['tecnolog√≠a', 'inteligencia', 'artificial', 'ai']):
            return f"{entity_query} tecnolog√≠a inteligencia artificial"
        else:
            return f"{entity_query} informaci√≥n completa"
    
    def _identify_central_theme(self, text: str) -> Optional[str]:
        """Identificar el tema central de la consulta"""
        text_lower = text.lower()
        
        # Temas pol√≠ticos/econ√≥micos
        if any(word in text_lower for word in ['pol√≠tico', 'presidente', 'econom√≠a', 'argentina', 'milei']):
            return 'pol√≠tica_econom√≠a'
        
        # Temas musicales
        if any(word in text_lower for word in ['banda', 'm√∫sica', 'rock', 'arctic', 'monkeys']):
            return 'm√∫sica'
        
        # Temas tecnol√≥gicos
        if any(word in text_lower for word in ['tecnolog√≠a', 'inteligencia', 'artificial', 'ai', 'datos']):
            return 'tecnolog√≠a'
        
        # Temas de investigaci√≥n general
        if any(word in text_lower for word in ['an√°lisis', 'investigar', 'estudiar', 'comparar']):
            return 'investigaci√≥n'
        
        return None
    
    def _build_themed_query(self, theme: str, original_query: str) -> str:
        """Construir query basado en tema identificado"""
        # Extraer palabras clave principales del query original
        main_words = self._extract_significant_words(original_query, min_words=2)
        
        theme_maps = {
            'pol√≠tica_econom√≠a': lambda words: f"{' '.join(words)} pol√≠tica argentina econ√≥mico",
            'm√∫sica': lambda words: f"{' '.join(words)} m√∫sica banda discograf√≠a",
            'tecnolog√≠a': lambda words: f"{' '.join(words)} tecnolog√≠a inteligencia artificial",
            'investigaci√≥n': lambda words: f"{' '.join(words)} an√°lisis investigaci√≥n datos"
        }
        
        if theme in theme_maps and main_words:
            return theme_maps[theme](main_words[:3])
        
        return None
    
    def _extract_significant_words(self, text: str, min_words: int = 2) -> List[str]:
        """Extraer palabras significativas evitando t√©rminos meta"""
        # Normalizar texto
        clean_text = re.sub(r'[^\w\s]', ' ', text.lower())
        clean_text = re.sub(r'\s+', ' ', clean_text).strip()
        
        # Extraer todas las palabras de 3+ caracteres
        words = re.findall(r'\b[a-z√°√©√≠√≥√∫√±]{3,}\b', clean_text)
        
        # Filtrar palabras significativas
        significant = []
        for word in words:
            # Incluir si est√° en preserve_words O si no est√° en meta_words
            if word in self.preserve_words or (word not in self.meta_words and len(word) > 2):
                significant.append(word)
        
        # Remover duplicados preservando orden
        seen = set()
        unique_significant = []
        for word in significant:
            if word not in seen:
                seen.add(word)
                unique_significant.append(word)
        
        return unique_significant[:6]  # M√°ximo 6 palabras
    
    def _generate_category_based_keywords(self, text: str) -> Optional[str]:
        """Generar keywords basados en categor√≠a de la consulta"""
        text_lower = text.lower()
        
        # An√°lisis pol√≠tico/biograf√≠a
        if any(word in text_lower for word in ['milei', 'javier', 'presidente', 'pol√≠tico']):
            return "javier milei presidente argentina pol√≠tica"
        
        # An√°lisis econ√≥mico
        if any(word in text_lower for word in ['econ√≥mico', 'inflaci√≥n', 'pib', 'argentina']):
            return "argentina econom√≠a inflaci√≥n datos estad√≠sticas"
        
        # Banda musical
        if any(word in text_lower for word in ['arctic', 'monkeys', 'banda']):
            return "arctic monkeys banda m√∫sica rock"
        
        # Tecnolog√≠a/IA
        if any(word in text_lower for word in ['inteligencia', 'artificial', 'tecnolog√≠a']):
            return "inteligencia artificial tecnolog√≠a machine learning"
        
        return None
    
    def _extract_any_useful_words(self, text: str) -> str:
        """√öltimo recurso: extraer cualquier palabra potencialmente √∫til"""
        words = re.findall(r'\b[a-z√°√©√≠√≥√∫√±A-Z√Å√â√ç√ì√ö√ë]{3,}\b', text)
        
        # Filtrar solo las m√°s cortas que no sean meta
        useful = []
        for word in words[:8]:  # Primeras 8 palabras
            word_lower = word.lower()
            if word_lower not in self.meta_words and len(word) >= 3:
                useful.append(word_lower)
        
        if useful:
            return ' '.join(useful[:4])
        else:
            return "informaci√≥n actualizada noticias"
    
    def _validate_keyword_quality(self, keywords: str) -> bool:
        """Validar que los keywords generados sean de buena calidad"""
        if not keywords or len(keywords.strip()) < 5:
            return False
        
        # Verificar que no contenga solo palabras meta
        words = keywords.lower().split()
        useful_words = [w for w in words if w not in self.meta_words]
        
        if len(useful_words) < 2:
            print(f"üö® LOW QUALITY: Only {len(useful_words)} useful words in '{keywords}'")
            return False
        
        # Verificar que no sea solo t√©rminos gen√©ricos
        generic_terms = {'informaci√≥n', 'general', 'completa', 'actualizada', 'datos'}
        if all(word in generic_terms for word in words):
            print(f"üö® TOO GENERIC: All words are generic in '{keywords}'")
            return False
        
        print(f"‚úÖ QUALITY VALIDATED: '{keywords}' has {len(useful_words)} useful words")
        return True
    
    def generate_multiple_search_variants(self, original_query: str, num_variants: int = 3) -> List[str]:
        """
        üéØ GENERAR M√öLTIPLES VARIANTES DE B√öSQUEDA PARA DIVERSIDAD DE FUENTES
        
        Genera diferentes enfoques de b√∫squeda para el mismo tema, 
        maximizando las posibilidades de encontrar fuentes diversas
        """
        base_keywords = self.generate_smart_keywords(original_query)
        variants = [base_keywords]  # Incluir versi√≥n base
        
        # Extraer palabras clave principales
        main_words = base_keywords.split()[:3]
        
        if len(main_words) >= 2:
            # Variante 1: Enfoque espec√≠fico + contexto
            variant1 = f"{main_words[0]} {main_words[1]} informaci√≥n detallada"
            if variant1 not in variants:
                variants.append(variant1)
            
            # Variante 2: Enfoque amplio + a√±o actual  
            variant2 = f"{' '.join(main_words)} noticias 2025"
            if variant2 not in variants:
                variants.append(variant2)
            
            # Variante 3: Enfoque de fuentes especializadas
            if len(main_words) >= 3:
                variant3 = f"{main_words[0]} {main_words[2]} an√°lisis"
                if variant3 not in variants:
                    variants.append(variant3)
        
        # Retornar solo el n√∫mero solicitado
        return variants[:num_variants]

# Instancia global para usar en unified_web_search_tool.py
intelligent_keyword_generator = IntelligentKeywordGenerator()

def get_intelligent_keywords(query: str, num_variants: int = 1) -> str:
    """
    üéØ FUNCI√ìN PRINCIPAL PARA REEMPLAZAR LAS FUNCIONES PROBLEM√ÅTICAS
    
    Args:
        query: Query original del usuario
        num_variants: N√∫mero de variantes (por defecto 1)
        
    Returns:
        str: Keywords inteligentes optimizados
    """
    if num_variants == 1:
        return intelligent_keyword_generator.generate_smart_keywords(query)
    else:
        variants = intelligent_keyword_generator.generate_multiple_search_variants(query, num_variants)
        return variants[0] if variants else "informaci√≥n actualizada"

def get_multiple_search_variants(query: str, num_variants: int = 3) -> List[str]:
    """
    üìä GENERAR M√öLTIPLES VARIANTES PARA B√öSQUEDAS DIVERSIFICADAS
    
    Args:
        query: Query original del usuario  
        num_variants: N√∫mero de variantes a generar
        
    Returns:
        List[str]: Lista de keywords variantes
    """
    return intelligent_keyword_generator.generate_multiple_search_variants(query, num_variants)